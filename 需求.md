- 所有的资料，作业，都以TXT格式保存以及操作。

# 大体的开发进度安排

1. 模拟系统时间

```java
public interface SystemTime{
    
}
```



1. 课程信息
2. 课外活动
3. 导航
4. 日志

# 持久化的

```java
//关于文件夹的结构:
/**
*要保存的内容有：
*用户的信息
*课程的信息，考试
*学生提交的文件以及模拟世界相应的元数据（模拟世界中的文件提交时间，区分真实世界）
*地图
*日志
*课外活动
*/
当前工作目录：
    	--Files
    		-- Map
    		--log
    		
    		--用户1
    			--课外活动
    			--UserInfor
    			--Classes
    				课表.txt
    				--数据结构
    					--homework
    						(原始文件和已压缩的文件)
    		--用户2
    		--用户3
```



- 本质上就是游戏存档。
- 两种策略：
  - 数据库，MySQL。JDBC，Java database connector。
    - 数据的查询：查询的语句
    - 数据的更改：插入
    - 数据的删除：
  - 文件读写：Java的文件读写，使用文件读写的话有现成的工具。

- 图要保存在本地，持久化。
  - Java本身有一个接口，可序列化(serializable)。



# 课程信息管理和查询

- 每个学生的课程数量以及名称不完全一样。



- 需求：

  - 查询课程：

    - 通过课程名称去查询

    - 打印整个课表，整周课表。

    - ```java
      //先打印课程表
      周一 课程1  课程2     
      周二 课程3 。。。。。。。。
      //然后询问想查询某一门课
      //已经指定选择哪一门课，打印其他细节
      ```

  - 上传作业、资料。
    - 对作业查重
      - 如果提交的作业 同名，但是具体内容不同（算哈希值判断，哈希值不同则判定为文件内容不同），我们就都保留下来。
    - 资料去重
  - 关于资料、作业的排序和查找的标准
    - 字典序，文件名的字典序
    - 上传时间、作业的截止日期。

- 有关系统管理员：

  - 修改课程信息：
    - 考试时间和考试地点
    - 上课的时间和上课地点
    - 上传新的课程资料
    - 发布新的课程

- 论文查重找到了库：[GitHub链接](https://github.com/yzqctf/3119005483/tree/main/Final%20commit)

## 如果使用文件读写

- 关于查询：
  - 先把所有的关联的文件都读取到内存里面，再做其他工作。
- 关于排序
  - 可能只需要读取文件的元数据，比如提交时间，文件的大小，根据这些来排序。
- 多关键字查询：
  - 先让用户选择按照什么关键字查询，然后再读取用户输入的关键字。
  - 然后根据所选的属性再做其他工作。

# 课外信息管理和查询  

- 关于活动信息：
  - 活动名称
  - 活动的开始时间和结束时间，具体到分钟，日期。
- 闹钟：
  - 周期提醒
    - 每周一次
    - 每天一次
  - 单次提醒
- 关于冲突检测：
  - 场景：
    - 添加课程的时候
    - 学生增加活动
  - 只需要提示冲突，并终止，不需要做其他工作。

# 课程导航

- 路径规划：规划的起点和终点可能在两个校区
  - 查询方式有三种，都只需要给出上课地点。
    - 课程名称
      - 课程优先判定为当天有，并且未开始。
      - 如果当天没有，或者或者已经开始，就询问用户。
      - 用户给否，直接终止。
      - 给是，则给用户查询本周的下一次课程或者下一周的这一次课程。
    - 上课时间，具体到 `周几 几点`
      - 如果给定的周几比当前星期几后，我们判定为本周的周几。
      - 如果给定的周几在本周已经过去了，我们判定为下周的周几。
        - 如果判定为下周，询问用户是否查询下一周。
        - 否，则直接终止。
    - 上课地点：
      - 不用考虑其他问题，直接给出从起点到给定上课地点的路径，相信用户不会自己骗自己。
- 关于导航导航策略：
  - 每一种策略建立一个图。
  - 最短距离策略：图的边的权值是两个端点之间的距离。
  - 最短时间策略：图的边的权值是两个端点之间的道路拥挤度（或者说花费的时间）。
  - 交通工具最短时间策略：



# 模拟系统时间

- 系统时间也要做持久化。闹钟也需要。
- 需要可以修改时间。
- 修改时间的倍数。
- 不能通过修改源代码的方式来修改，肯定需要相应的API。
- Calendar class

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203162158731.png" alt="image-20220316215829639" style="zoom:67%;" />

# 日志

- 有一个文件叫log.txt
- 每次执行一个操作就更新log。
- 每个操作执行完毕return之前执行一条写入日志的代码。

# 疑问

- 是否需要从管理系统中打开并查看作业等的具体内容？
  - 不用。

- 查询、排序的对象是只对学生已上传（或老师）的文件查询，还是对诸如未提交的作业也需要。
  - 只要对已提交的文件，范围限定在学生或老师已经提交的所有文件上。

- 每条道路的拥挤度是固定不变的吗？还是模拟真实世界，可能变化。
  - 早八的拥挤度一张
  - 中午去吃饭的时候一张图
  - 晚上回宿舍一张图
  - 拥挤度是有方向的，一条路在两个方向上拥挤度不同。

- 是否会用到建筑物本身的属性？
  - 属性：就指的是建筑物的功能。

- 如果使用数据库，数据库本身自带查询和排序，这个查询和排序的方法如何体现时间复杂度。
- 是否需要新用户注册模块？以及最低的用户个数要求？



# 关于Comparator接口

```java
public interface Comparator<T> {
    public int compare(T o1, T o2) {
        //如果o1 大于 o2就返回正值，相等返回0，否则返回负值
    }
}
public class example {
    //字符串长度比较器，java默认的比较字符串是按照字典序比较
    private class StringLenghtComparator implements Comparator<String> {
        public int compare(String s1 , String s2) {
            return s1.length() - s2.length();
        }
    }
    public static void Sort(Comparator<String> cp , String[] str) {
        int cmp = cp.compare(str[i], str [j]);
        if(cmp > 0) {
            .......
        }
        else {
            .....
        }
    }
    public static void main(String[] args) {
        String[] strs = new String[114514];
        //给数组赋值的略过
        Comparator<String> cp = new StringLenghtComparator();
        example.Sort(cp, s
    }
}
```

