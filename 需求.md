- 所有的资料，作业，都以TXT格式保存以及操作。

# 交互方式

1. 先询问是以学生还是老师身份登录。
   1. 扣1学生
   2. 扣2管理员
2. 以学生身份登录之后：
   - 以下是学生端可以使用的功能：
     - 扣1课程信息管理和查询
       - 扣1课程查询，询问按照哪种方式查询
         - 扣1按照课程名称查询，提示用户输入课程名称。
         - 扣2通过课表查询。先打印当周课表。然后询问用户要查哪一门课的信息。
       - 扣2上传作业和资料。
         1. 询问用户要选择哪一门课。
         2. 询问用户是传作业还是资料。
            1. 扣1传作业
            2. 扣2传资料
         3. 传作业要查重，传资料要去重。（要对上传进来的文件压缩）
         4. 传完作业提示用户重复度是多少。
         5. 传完资料，提示用户资料是否此前已经存在。
       - 扣3查询作业和资料
         1. 先询问用户是要查询时间段，还是要选择某一门课程进行查询
            1. 扣1时间段
            2. 扣2课程
         2. 按时间段：
            1. 直接打印出选定时间段内的**所有课程的**所有作业。
         3. 按课程：
            1. 询问按照哪种方式排序输出
               1. 
            2. 打印结果
       - 扣4查询考试相关信息
         1. 扣1按时间段查询
         2. 扣2按课程查询
            1. 询问排序方式
            2. 打印结果
     - 扣2课外信息管理和查询
       - 无论如何都把所有的课外活动先给他打印出来
       - 然后再问它是想干什么。
       - 扣1添加新的活动
         - 需要进行时间冲突检测。只需要提示冲突即可。
       - 扣2删除活动
       - 扣3设定闹钟
         - 扣1设定一次性
         - 扣2设定一天一次
         - 扣3设定一周一次
     - 扣3课程导航
       1. 使用Map<建筑物，有向图的点>
       2. 先询问用户的当前位置。（就近选择）
          - 图书馆
          - 教学楼
          - 宿舍
          - 食堂
          - 操场
          - 小卖部
          - 学活
       3. 询问按照哪一种方式查询
          1. 按照课程名称查询
          2. 按照时间查询
          3. 按照地点查询
          4. （需要让用户确认终点是否是他想要的）
       4. 询问导航策略。
       5. 给结果。
3. 以老师身份登录：
   1. 询问是要修改什么：
      1. 考试时间和考试地点
      2. 上课的时间和上课地点
      3. 上传新的课程资料
      4. 发布新的课程

# 大体的开发进度安排

1. ### 模拟系统时间

```java
/**
*年 月 日 时 分 
*星期几
*/
public interface SystemTime{
    String getYear();
    String getMonth();
    String getDay();
    String getMin();
    String getHour();
    String getWeek();
    String getData();
    void setYear();
    void setMonth();
    void setDay();
    void PauseTime(); //暂停时间
    void RestartTime();//重新启动时间
    void setRate();//设置时间流速倍率
}
public class Clock{
    public Clock setClock();
    public String Alarm();
    public void on();
    public void off();
}
```

1. ### 课程信息管理和查询

```java
/**
*
*/
public interface CourseManager {
    
    public SearchCourse(String CourseName);
    public void PrintTable();
}
public class CLASS {
    
} 
```



1. 课外活动
2. 导航
3. 日志

# 持久化的

```java
//关于文件夹的结构:
/**
*要保存的内容有：
*用户的信息
*课程的信息，考试
*学生提交的文件以及模拟世界相应的元数据（模拟世界中的文件提交时间，区分真实世界）
*地图
*日志
*课外活动
*/
当前工作目录：
    	/*--Files
    		-- Map
    		--log
    		
    		--用户1
    			--课外活动
    			--UserInfor
    			--Classes
    				课表.txt
    				--数据结构
    					--homework
    						(原始文件和已压缩的文件)
    		--用户2
    		--用户3*/
    
   --UserFiles
    	--八班
    		--八班的对象的序列化文件
    		--小明
    			--小明对象的序列化文件
    			--小明的作业，资料的压缩文件
    		--小亮
    			--小亮对象的序列化文件
    			--小亮的作业，资料的压缩文件
    	--九班
    		--九班的对象的序列化文件
```



- 本质上就是游戏存档。
- 两种策略：
  - 数据库，MySQL。JDBC，Java database connector。
    - 数据的查询：查询的语句
    - 数据的更改：插入
    - 数据的删除：
  - 文件读写：Java的文件读写，使用文件读写的话有现成的工具。

- 图要保存在本地，持久化。
  - Java本身有一个接口，可序列化(serializable)。



# 课程信息管理和查询

## 课程信息的存储方式

### 关于周期表

- 七个节点

```java
   --UserFiles
    	--八班
       		周期表（班级的所有同学共有的课程）
       		非周期表（班级只生效一次的集体活动）
    		--八班的所有同学的用户信息序列化文件
    		--小明
       			个人课外活动表
       			个人独有的课程，比如公选课的，表
    			--小明的作业，资料的压缩文件
    		--小亮
    			--小亮的作业，资料的压缩文件
    	--九班
    		--九班的对象的序列化文件
```



## 排序的几种方式

- 查课
  - 字典序
  - 打印课表
- 查找就只有二分。
- 比较器：





- 每个学生的课程数量以及名称不完全一样。



- 需求：

  - 查询课程：

    - 通过课程名称去查询

    - 打印整个课表，整周课表。

    - ```java
      //先打印课程表
      周一 课程1 (上课时间 上课地点)  课程2 （上课时间 上课地点）     
      周二 课程3 （上课时间 上课地点）。。。。。。。。
      //然后询问想查询某一门课
      //已经指定选择哪一门课，打印其他细节
      ```

  - 上传作业、资料。
    - 对作业查重
      - 如果提交的作业 同名，但是具体内容不同（算哈希值判断，哈希值不同则判定为文件内容不同），我们就都保留下来。
    - 资料去重
  - 关于资料、作业的排序和查找的标准
    - 字典序，文件名的字典序
    - 上传时间、作业的截止日期。

- 有关系统管理员：

  - 修改课程信息：
    - 考试时间和考试地点
    - 上课的时间和上课地点
    - 上传新的课程资料
    - 发布新的课程

- 论文查重找到了库：[GitHub链接](https://github.com/yzqctf/3119005483/tree/main/Final%20commit)

## 如果使用文件读写

- 关于查询：
  - 先把所有的关联的文件都读取到内存里面，再做其他工作。
- 关于排序
  - 可能只需要读取文件的元数据，比如提交时间，文件的大小，根据这些来排序。
- 多关键字查询：
  - 先让用户选择按照什么关键字查询，然后再读取用户输入的关键字。
  - 然后根据所选的属性再做其他工作。

# 课外信息管理和查询  

- 关于活动信息：
  - 活动名称
  - 活动的开始时间和结束时间，具体到分钟，日期。
- 闹钟：
  - 周期提醒
    - 每周一次
    - 每天一次
  - 单次提醒
- 关于冲突检测：
  - 场景：
    - 添加课程的时候
    - 学生增加活动
  - 只需要提示冲突，并终止，不需要做其他工作。

# 课程导航

- 路径规划：规划的起点和终点可能在两个校区
  - 查询方式有三种，都只需要给出上课地点。
    - 课程名称
      - 课程优先判定为当天有，并且未开始。
      - 如果当天没有，或者或者已经开始，就询问用户。
      - 用户给否，直接终止。
      - 给是，则给用户查询本周的下一次课程或者下一周的这一次课程。
    - 上课时间，具体到 `周几 几点`
      - 如果给定的周几比当前星期几后，我们判定为本周的周几。
      - 如果给定的周几在本周已经过去了，我们判定为下周的周几。
        - 如果判定为下周，询问用户是否查询下一周。
        - 否，则直接终止。
    - 上课地点：
      - 不用考虑其他问题，直接给出从起点到给定上课地点的路径，相信用户不会自己骗自己。
- 关于导航导航策略：
  - 每一种策略建立一个图。
  - 最短距离策略：图的边的权值是两个端点之间的距离。
  - 最短时间策略：图的边的权值是两个端点之间的道路拥挤度（或者说花费的时间）。
  - 交通工具最短时间策略：



# 模拟系统时间

- 系统时间也要做持久化。闹钟也需要。
- 需要可以修改时间。
- 修改时间的倍数。
- 不能通过修改源代码的方式来修改，肯定需要相应的API。
- Calendar class

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203162158731.png" alt="image-20220316215829639" style="zoom:67%;" />

# 日志

- 有一个文件叫log.txt
- 每次执行一个操作就更新log。
- 每个操作执行完毕return之前执行一条写入日志的代码。

# 疑问

- 是否需要从管理系统中打开并查看作业等的具体内容？
  - 不用。

- 查询、排序的对象是只对学生已上传（或老师）的文件查询，还是对诸如未提交的作业也需要。
  - 只要对已提交的文件，范围限定在学生或老师已经提交的所有文件上。

- 每条道路的拥挤度是固定不变的吗？还是模拟真实世界，可能变化。
  - 早八的拥挤度一张
  - 中午去吃饭的时候一张图
  - 晚上回宿舍一张图
  - 拥挤度是有方向的，一条路在两个方向上拥挤度不同。

- 是否会用到建筑物本身的属性？
  - 属性：就指的是建筑物的功能。

- 如果使用数据库，数据库本身自带查询和排序，这个查询和排序的方法如何体现时间复杂度。
- 是否需要新用户注册模块？以及最低的用户个数要求？



# 关于Comparator接口

```java
public interface Comparator<T> {
    public int compare(T o1, T o2) {
        //如果o1 大于 o2就返回正值，相等返回0，否则返回负值
    }
}
public class example {
    //字符串长度比较器，java默认的比较字符串是按照字典序比较
    private class StringLenghtComparator implements Comparator<String> {
        public int compare(String s1 , String s2) {
            return s1.length() - s2.length();
        }
    }
    public static void Sort(Comparator<String> cp , String[] str) {
        int cmp = cp.compare(str[i], str [j]);
        if(cmp > 0) {
            .......
        }
        else {
            .....
        }
    }
    public static void main(String[] args) {
        String[] strs = new String[114514];
        //给数组赋值的略过
        Comparator<String> cp = new StringLenghtComparator();
        example.Sort(cp, s
    }
}
```

